package com.wordnik.swagger.codegen;

import com.wordnik.swagger.models.*;
import com.wordnik.swagger.models.properties.*;

import java.util.*;

public class CodegenModel {
  public String parent;
  public String name, namespaceName, classname, description, classVarName, modelJson, variableName;
  public String defaultValue;
  public List<CodegenProperty> vars = new ArrayList<CodegenProperty>();
  public Set<String> imports = new HashSet<String>();
  public Boolean hasVars, emptyVars, hasMoreModels;
  public ExternalDocs externalDocs;
}

package com.wordnik.swagger.codegen;

import com.wordnik.swagger.models.*;
import com.wordnik.swagger.models.properties.*;

import java.util.*;

public class CodegenModel {
  public String parent;
  public String name, namespaceName, classname, description, classVarName, modelJson, variableName;
  public String defaultValue;
  public List<CodegenProperty> vars = new ArrayList<CodegenProperty>();
  public Set<String> imports = new HashSet<String>();
  public Boolean hasVars, emptyVars, hasMoreModels;
  public ExternalDocs externalDocs;
}

package com.wordnik.swagger.codegen;

import com.wordnik.swagger.codegen.examples.ExampleGenerator;
import com.wordnik.swagger.models.*;
import com.wordnik.swagger.models.auth.ApiKeyAuthDefinition;
import com.wordnik.swagger.models.auth.BasicAuthDefinition;
import com.wordnik.swagger.models.auth.In;
import com.wordnik.swagger.models.auth.SecuritySchemeDefinition;
import com.wordnik.swagger.models.parameters.*;
import com.wordnik.swagger.models.properties.*;
import com.wordnik.swagger.util.Json;

import org.apache.commons.lang.StringUtils;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.util.*;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class DefaultCodegen {
  Logger LOGGER = LoggerFactory.getLogger(DefaultCodegen.class);

  protected String outputFolder = "";
  protected Set<String> defaultIncludes = new HashSet<String>();
  protected Map<String, String> typeMapping = new HashMap<String, String>();
  protected Map<String, String> instantiationTypes = new HashMap<String, String>();
  protected Set<String> reservedWords = new HashSet<String>();
  protected Set<String> languageSpecificPrimitives = new HashSet<String>();
  protected Map<String, String> importMapping = new HashMap<String, String>();
  protected String modelPackage = "", apiPackage = "", fileSuffix;
  protected Map<String, String> apiTemplateFiles = new HashMap<String, String>();
  protected Map<String, String> modelTemplateFiles = new HashMap<String, String>();
  protected String templateDir;
  protected Map<String, Object> additionalProperties = new HashMap<String, Object>();
  protected List<SupportingFile> supportingFiles = new ArrayList<SupportingFile>();

  public void processOpts(){
    if(additionalProperties.containsKey("templateDir")) {
      this.setTemplateDir((String)additionalProperties.get("templateDir"));
    }
  }

  // override with any special post-processing
  public Map<String, Object> postProcessModels(Map<String, Object> objs) {
    return objs;
  }

  // override with any special post-processing
  public Map<String, Object> postProcessOperations(Map<String, Object> objs) {
    return objs;
  }

  // override with any special post-processing
  public Map<String, Object> postProcessSupportingFileData(Map<String, Object> objs) {
    return objs;
  }

  // override with any special handling of the entire swagger spec
  public void processSwagger(Swagger swagger) {}

  // override with any special text escaping logic
  public String escapeText(String input) {
    if(input != null) {
      String output = input.replaceAll("\n", "\\\\n");
      output = output.replace("\"", "\\\"");
      return output;
    }
    return input;
  }

  public Set<String> defaultIncludes() {
    return defaultIncludes;
  }
  public Map<String, String> typeMapping() {
    return typeMapping;
  }
  public Map<String, String> instantiationTypes() {
    return instantiationTypes;
  }
  public Set<String> reservedWords() {
    return reservedWords;
  }
  public Set<String> languageSpecificPrimitives() {
    return languageSpecificPrimitives;
  }
  public Map<String, String> importMapping() {
    return importMapping;
  }
  public String modelPackage() {
    return modelPackage;
  }
  public String apiPackage() {
    return apiPackage;
  }
  public String fileSuffix() {
    return fileSuffix;
  }
  public String templateDir() {
    return templateDir;
  }
  public Map<String, String> apiTemplateFiles() {
    return apiTemplateFiles;
  }
  public Map<String, String> modelTemplateFiles() {
    return modelTemplateFiles;
  }

  public String apiFileFolder() {
    return outputFolder + "/" + apiPackage().replace('.', File.separatorChar);
  }

  public String modelFileFolder() {
    return outputFolder + "/" + modelPackage().replace('.', File.separatorChar);
  }

  public Map<String, Object> additionalProperties() {
    return additionalProperties;
  }
  public List<SupportingFile> supportingFiles() {
    return supportingFiles;
  }
  public String outputFolder() {
    return outputFolder;
  }

  public void setOutputDir(String dir) {
    this.outputFolder = dir;
  }
  public String getOutputDir() {
    return outputFolder();
  }

  public void setTemplateDir(String templateDir) {
    this.templateDir = templateDir;
  }

  public String toApiFilename(String name) {
    return toApiName(name);
  }

  public String toApiVarName(String name) {
    return snakeCase(name);
  }

  public String toModelFilename(String name) {
    return initialCaps(name);
  }

  public String toOperationId(String operationId) { return operationId; }

  public String toVarName(String name) {
    if(reservedWords.contains(name))
      return escapeReservedWord(name);
    else
      return name;
  }

  public String toParamName(String name) {
    if(reservedWords.contains(name)) {
      return escapeReservedWord(name);
    }
    return name;
  }


  public String escapeReservedWord(String name) {
    throw new RuntimeException("reserved word " + name + " not allowed");
  }

  public String toModelImport(String name) {
    if("".equals(modelPackage()))
      return name;
    else
      return modelPackage() + "." + name;
  }

  public String toApiImport(String name) {
    return apiPackage() + "." + name;
  }

  public DefaultCodegen() {
    defaultIncludes = new HashSet<String>(
      Arrays.asList("double",
        "int",
        "long",
        "short",
        "char",
        "float",
        "String",
        "boolean",
        "Boolean",
        "Double",
        "Void",
        "Integer",
        "Long",
        "Float")
      );

    typeMapping = new HashMap<String, String>();
    typeMapping.put("array", "List");
    typeMapping.put("map", "Map");
    typeMapping.put("List", "List");
    typeMapping.put("boolean", "Boolean");
    typeMapping.put("string", "String");
    typeMapping.put("int", "Integer");
    typeMapping.put("float", "Float");
    typeMapping.put("number", "BigDecimal");
    typeMapping.put("DateTime", "Date");
    typeMapping.put("long", "Long");
    typeMapping.put("short", "Short");
    typeMapping.put("char", "String");
    typeMapping.put("double", "Double");
    typeMapping.put("object", "Object");
    typeMapping.put("integer", "Integer");

    instantiationTypes = new HashMap<String, String>();

    reservedWords = new HashSet<String>();

    importMapping = new HashMap<String, String>();
    importMapping.put("BigDecimal", "java.math.BigDecimal");
    importMapping.put("UUID", "java.util.UUID");
    importMapping.put("File", "java.io.File");
    importMapping.put("Date", "java.util.Date");
    importMapping.put("Timestamp", "java.sql.Timestamp");
    importMapping.put("Map", "java.util.Map");
    importMapping.put("HashMap", "java.util.HashMap");
    importMapping.put("Array", "java.util.List");
    importMapping.put("ArrayList", "java.util.ArrayList");
    importMapping.put("List", "java.util.*");
    importMapping.put("Set", "java.util.*");
    importMapping.put("DateTime", "org.joda.time.*");
    importMapping.put("LocalDateTime", "org.joda.time.*");
    importMapping.put("LocalDate", "org.joda.time.*");
    importMapping.put("LocalTime", "org.joda.time.*");
  }


  public String generateExamplePath(String path, Operation operation) {
    StringBuilder sb = new StringBuilder();
    sb.append(path);

    if(operation.getParameters() != null) {
      int count = 0;

      for(Parameter param : operation.getParameters()) {
        if(param instanceof QueryParameter) {
          StringBuilder paramPart = new StringBuilder();
          QueryParameter qp = (QueryParameter) param;

          if(count == 0)
            paramPart.append("?");
          else
            paramPart.append(",");
          count += 1;
          if(!param.getRequired())
            paramPart.append("[");
          paramPart.append(param.getName()).append("=");
          paramPart.append("{");
          if(qp.getCollectionFormat() != null) {
            paramPart.append(param.getName() + "1");
            if("csv".equals(qp.getCollectionFormat()))
              paramPart.append(",");
            else if("pipes".equals(qp.getCollectionFormat()))
              paramPart.append("|");
            else if("tsv".equals(qp.getCollectionFormat()))
              paramPart.append("\t");
            else if("multi".equals(qp.getCollectionFormat())) {
              paramPart.append("&").append(param.getName()).append("=");
              paramPart.append(param.getName() + "2");
            }
          }
          else {
            paramPart.append(param.getName());
          }
          paramPart.append("}");
          if(!param.getRequired())
            paramPart.append("]");
          sb.append(paramPart.toString());
        }
      }
    }

    return sb.toString();
  }

  public String toInstantiationType(Property p) {
    if (p instanceof MapProperty) {
      MapProperty ap = (MapProperty) p;
      String inner = getSwaggerType(ap.getAdditionalProperties());
      return instantiationTypes.get("map") + "<String, " + inner + ">";
    }
    else if (p instanceof ArrayProperty) {
      ArrayProperty ap = (ArrayProperty) p;
      String inner = getSwaggerType(ap.getItems());
      return instantiationTypes.get("array") + "<" + inner + ">";
    }
    else
      return null;
  }

  public String toDefaultValue(Property p) {
    if(p instanceof StringProperty)
      return "null";
    else if (p instanceof BooleanProperty)
      return "null";
    else if(p instanceof DateProperty)
      return "null";
    else if(p instanceof DateTimeProperty)
      return "null";
    else if (p instanceof DoubleProperty) {
      DoubleProperty dp = (DoubleProperty) p;
      if(dp.getDefault() != null) {
        return dp.getDefault().toString();
      }
      return "null";
    }
    else if (p instanceof FloatProperty) {
      FloatProperty dp = (FloatProperty) p;
      if(dp.getDefault() != null) {
        return dp.getDefault().toString();
      }
      return "null";
    }
    else if (p instanceof IntegerProperty) {
      IntegerProperty dp = (IntegerProperty) p;
      if(dp.getDefault() != null) {
        return dp.getDefault().toString();
      }
      return "null";
    }
    else if (p instanceof LongProperty) {
      LongProperty dp = (LongProperty) p;
      if(dp.getDefault() != null) {
        return dp.getDefault().toString();
      }
      return "null";
    }
    else if (p instanceof MapProperty) {
      MapProperty ap = (MapProperty) p;
      String inner = getSwaggerType(ap.getAdditionalProperties());
      return "new HashMap<String, " + inner + ">() ";
    }
    else if (p instanceof ArrayProperty) {
      ArrayProperty ap = (ArrayProperty) p;
      String inner = getSwaggerType(ap.getItems());
      return "new ArrayList<" + inner + ">() ";
    }
    else
      return "null";
  }

  /**
   * returns the swagger type for the property
   **/
  public String getSwaggerType(Property p) {
    String datatype = null;
    if(p instanceof StringProperty)
      datatype = "string";
    else if (p instanceof BooleanProperty)
      datatype = "boolean";
    else if(p instanceof DateProperty)
      datatype = "date";
    else if(p instanceof DateTimeProperty)
      datatype = "DateTime";
    else if (p instanceof DoubleProperty)
      datatype = "double";
    else if (p instanceof FloatProperty)
      datatype = "float";
    else if (p instanceof IntegerProperty)
      datatype = "integer";
    else if (p instanceof LongProperty)
      datatype = "long";
    else if (p instanceof MapProperty)
      datatype = "map";
    else if (p instanceof DecimalProperty)
      datatype = "number";
    else if (p instanceof RefProperty) {
      RefProperty r = (RefProperty)p;
      datatype = r.get$ref();
      if(datatype.indexOf("#/definitions/") == 0)
        datatype = datatype.substring("#/definitions/".length());
    }
    else {
      if(p != null) datatype = p.getType();
    }
    return datatype;
  }

  public String snakeCase(String name) {
      return (name.length() > 0) ? (Character.toLowerCase(name.charAt(0)) + name.substring(1)) : "";
  }

  public String initialCaps(String name) {
    return StringUtils.capitalize(name);
  }

  public String getTypeDeclaration(String name) {
    return name;
  }

  public String getTypeDeclaration(Property p) {
    String swaggerType = getSwaggerType(p);
    if(typeMapping.containsKey(swaggerType))
      return typeMapping.get(swaggerType);
    return swaggerType;
  }

  public String toApiName(String name) {
    if(name.length() == 0)
      return "DefaultApi";
    return initialCaps(name) + "Api";
  }

  public String toModelName(String name) {
    return initialCaps(name);
  }

  public CodegenModel fromModel(String name, Model model) {
    CodegenModel m = CodegenModelFactory.newInstance(CodegenModelType.MODEL);
    if(reservedWords.contains(name))
      m.name = escapeReservedWord(name);
    else
      m.name = name;
    m.description = escapeText(model.getDescription());
    m.classname = toModelName(name);
    m.classVarName = toVarName(name);
    m.modelJson = Json.pretty(model);
    m.externalDocs = model.getExternalDocs();
    int count = 0;
    if(model instanceof ArrayModel) {
      ArrayModel am = (ArrayModel) model;
      ArrayProperty arrayProperty = new ArrayProperty(am.getItems());
      CodegenProperty cp = fromProperty(name, arrayProperty);
      if(cp.complexType != null && !defaultIncludes.contains(cp.complexType))
        m.imports.add(cp.complexType);
      m.parent = toInstantiationType(arrayProperty);
      String containerType = cp.containerType;
      if(instantiationTypes.containsKey(containerType))
        m.imports.add(instantiationTypes.get(containerType));
      if(typeMapping.containsKey(containerType)) {
        containerType = typeMapping.get(containerType);
        cp.containerType = containerType;
        m.imports.add(containerType);
      }
    }
    else if (model instanceof RefModel) {
      // TODO
    }
    else {
      ModelImpl impl = (ModelImpl) model;
      if(impl.getAdditionalProperties() != null) {
        MapProperty mapProperty = new MapProperty(impl.getAdditionalProperties());
        CodegenProperty cp = fromProperty(name, mapProperty);
        if(cp.complexType != null && !defaultIncludes.contains(cp.complexType))
          m.imports.add(cp.complexType);
        m.parent = toInstantiationType(mapProperty);
        String containerType = cp.containerType;
        if(instantiationTypes.containsKey(containerType))
          m.imports.add(instantiationTypes.get(containerType));
        if(typeMapping.containsKey(containerType)) {
          containerType = typeMapping.get(containerType);
          cp.containerType = containerType;
          m.imports.add(containerType);
        }
      }
      if(impl.getProperties() != null && impl.getProperties().size() > 0) {
        m.hasVars = true;
        for(String key: impl.getProperties().keySet()) {
          Property prop = impl.getProperties().get(key);

          if(prop == null) {
            LOGGER.warn("null property for " + key);
          }
          else {
            CodegenProperty cp;
            try{
              cp = fromProperty(key, prop);
            }
            catch(Exception e) {
              System.out.println("failed to process model " + name);
              throw new RuntimeException(e);
            }
            cp.required = null;
            if(impl.getRequired() != null) {
              for(String req : impl.getRequired()) {
                if(key.equals(req))
                  cp.required = true;
              }
            }
            if(cp.complexType != null && !defaultIncludes.contains(cp.complexType)) {
              m.imports.add(cp.complexType);
            }
            m.vars.add(cp);
            count += 1;
            if(count != impl.getProperties().keySet().size())
              cp.hasMore = new Boolean(true);
            if(cp.isContainer != null) {
              String arrayImport = typeMapping.get("array");
              if(arrayImport != null &&
                !languageSpecificPrimitives.contains(arrayImport) &&
                !defaultIncludes.contains(arrayImport))
                m.imports.add(arrayImport);
            }

            if(cp.complexType != null &&
              !languageSpecificPrimitives.contains(cp.complexType) &&
              !defaultIncludes.contains(cp.complexType))
              m.imports.add(cp.complexType);

            if(cp.baseType != null &&
              !languageSpecificPrimitives.contains(cp.baseType) &&
              !defaultIncludes.contains(cp.baseType))
              m.imports.add(cp.baseType);
          }
        }
      }
      else {
        m.emptyVars = true;
      }
    }
    return m;
  }

  public String getterAndSetterCapitalize(String name) {
    if (name == null || name.length() == 0) {
      return name;
    }

    return camelize(toVarName(name));

  }

  public CodegenProperty fromProperty(String name, Property p) {
    if(p == null) {
      LOGGER.error("unexpected missing property for name " + null);
      return null;
    }
    CodegenProperty property = CodegenModelFactory.newInstance(CodegenModelType.PROPERTY);

    property.name = toVarName(name);
    property.baseName = name;
    property.description = escapeText(p.getDescription());
    property.getter = "get" + getterAndSetterCapitalize(name);
    property.setter = "set" + getterAndSetterCapitalize(name);
    property.example = p.getExample();
    property.defaultValue = toDefaultValue(p);
    property.jsonSchema = Json.pretty(p);

    String type = getSwaggerType(p);
    if(p instanceof AbstractNumericProperty) {
      AbstractNumericProperty np = (AbstractNumericProperty) p;
      property.minimum = np.getMinimum();
      property.maximum = np.getMaximum();
      property.exclusiveMinimum = np.getExclusiveMinimum();
      property.exclusiveMaximum = np.getExclusiveMaximum();

      // legacy support
      Map<String, Object> allowableValues = new HashMap<String, Object>();
      if(np.getMinimum() != null)
        allowableValues.put("min", np.getMinimum());
      if(np.getMaximum() != null)
        allowableValues.put("max", np.getMaximum());
      property.allowableValues = allowableValues;
    }

    if(p instanceof StringProperty) {
      StringProperty sp = (StringProperty) p;
      property.maxLength = sp.getMaxLength();
      property.minLength = sp.getMinLength();
      property.pattern = sp.getPattern();
      if(sp.getEnum() != null) {
        List<String> _enum = sp.getEnum();
        property._enum = _enum;
        property.isEnum = true;

        // legacy support
        Map<String, Object> allowableValues = new HashMap<String, Object>();
        allowableValues.put("values", _enum);
        property.allowableValues = allowableValues;
      }
    }

    property.datatype = getTypeDeclaration(p);

    // this can cause issues for clients which don't support enums
    if(property.isEnum)
      property.datatypeWithEnum = StringUtils.capitalize(property.name) + "Enum";
    else
      property.datatypeWithEnum = property.datatype;

    property.baseType = getSwaggerType(p);

    if(p instanceof ArrayProperty) {
      property.isContainer = true;
      property.containerType = "array";
      ArrayProperty ap = (ArrayProperty) p;
      CodegenProperty cp = fromProperty("inner", ap.getItems());
      if(cp == null) {
        LOGGER.warn("skipping invalid property " + Json.pretty(p));
      }
      else {
        property.baseType = getSwaggerType(p);
        if(!languageSpecificPrimitives.contains(cp.baseType))
          property.complexType = cp.baseType;
        else
          property.isPrimitiveType = true;
      }
    }
    else if(p instanceof MapProperty) {
      property.isContainer = true;
      property.containerType = "map";
      MapProperty ap = (MapProperty) p;
      CodegenProperty cp = fromProperty("inner", ap.getAdditionalProperties());

      property.baseType = getSwaggerType(p);
      if(!languageSpecificPrimitives.contains(cp.baseType))
        property.complexType = cp.baseType;
      else
        property.isPrimitiveType = true;
    }
    else {
        setNonArrayMapProperty(property, type);
    }
    return property;
  }

  protected void setNonArrayMapProperty(CodegenProperty property, String type) {
    property.isNotContainer = true;
      if(languageSpecificPrimitives().contains(type))
        property.isPrimitiveType = true;
      else
        property.complexType = property.baseType;
    }

  private Response findMethodResponse(Map<String, Response> responses) {

    String code = null;
    for(String responseCode : responses.keySet()) {
      if (responseCode.startsWith("2") || responseCode.equals("default")) {
        if (code == null || code.compareTo(responseCode) > 0) {
          code = responseCode;
        }
      }
    }
    if (code == null)
      return null;
    return responses.get(code);
  }

  public CodegenOperation fromOperation(String path, String httpMethod, Operation operation, Map<String, Model> definitions) {
    CodegenOperation op = CodegenModelFactory.newInstance(CodegenModelType.OPERATION);
    Set<String> imports = new HashSet<String>();

    String operationId = operation.getOperationId();
    if(operationId == null) {
      String tmpPath = path;
      tmpPath = tmpPath.replaceAll("\\{", "");
      tmpPath = tmpPath.replaceAll("\\}", "");
      String[] parts = (tmpPath + "/" + httpMethod).split("/");
      StringBuilder builder = new StringBuilder();
      if("/".equals(tmpPath)) {
        // must be root tmpPath
        builder.append("root");
      }
      for(int i = 0; i < parts.length; i++) {
        String part = parts[i];
        if(part.length() > 0) {
          if(builder.toString().length() == 0)
            part = Character.toLowerCase(part.charAt(0)) + part.substring(1);
          else
            part = initialCaps(part);
          builder.append(part);
        }
      }
      operationId = builder.toString();
      LOGGER.warn("generated operationId " + operationId);
    }
    op.path = path;
    op.operationId = toOperationId(operationId);
    op.summary = escapeText(operation.getSummary());
    op.notes = escapeText(operation.getDescription());
    op.tags = operation.getTags();

    if(operation.getConsumes() != null && operation.getConsumes().size() > 0) {
      List<Map<String, String>> c = new ArrayList<Map<String, String>>();
      int count = 0;
      for(String key: operation.getConsumes()) {
        Map<String, String> mediaType = new HashMap<String, String>();
        mediaType.put("mediaType", key);
        if (count < operation.getConsumes().size())
          mediaType.put("hasMore", "true");
        else
          mediaType.put("hasMore", null);
        count += 1;
        c.add(mediaType);
      }
      op.consumes = c;
      op.hasConsumes = true;
    }

    if(operation.getProduces() != null && operation.getProduces().size() > 0) {
      List<Map<String, String>> c = new ArrayList<Map<String, String>>();
      int count = 0;
      for(String key: operation.getProduces()) {
        Map<String, String> mediaType = new HashMap<String, String>();
        mediaType.put("mediaType", key);
        count += 1;
        if (count < operation.getProduces().size())
          mediaType.put("hasMore", "true");
        else
          mediaType.put("hasMore", null);
        c.add(mediaType);
      }
      op.produces = c;
      op.hasProduces = true;
    }

    if (operation.getResponses() != null && !operation.getResponses().isEmpty()) {
      Response methodResponse = findMethodResponse(operation.getResponses());
      CodegenResponse methodCodegenResponse = null;

      for (Map.Entry<String, Response> entry : operation.getResponses().entrySet()) {
        Response response = entry.getValue();
        CodegenResponse r = fromResponse(entry.getKey(), response);
        r.hasMore = true;
        if(r.baseType != null &&
            !defaultIncludes.contains(r.baseType) &&
            !languageSpecificPrimitives.contains(r.baseType))
          imports.add(r.baseType);

        if (response == methodResponse)
          methodCodegenResponse = r;
        op.responses.add(r);
      }
      op.responses.get(op.responses.size() - 1).hasMore = false;

    if(methodResponse != null) {
      if (methodResponse.getSchema() != null) {
        CodegenProperty cm = fromProperty("response", methodResponse.getSchema());

        Property responseProperty = methodResponse.getSchema();

        if(responseProperty instanceof ArrayProperty) {
          ArrayProperty ap = (ArrayProperty) responseProperty;
          CodegenProperty innerProperty = fromProperty("response", ap.getItems());
          op.returnBaseType = innerProperty.baseType;
        }
        else {
          if(cm.complexType != null)
            op.returnBaseType = cm.complexType;
          else
            op.returnBaseType = cm.baseType;
        }
        op.examples = new ExampleGenerator(definitions).generate(methodResponse.getExamples(), operation.getProduces(), responseProperty);
        op.defaultResponse = toDefaultValue(responseProperty);
        op.returnType = cm.datatype;
        if(cm.isContainer != null) {
          op.returnContainer = cm.containerType;
          if("map".equals(cm.containerType))
            op.isMapContainer = Boolean.TRUE;
          else if ("list".equalsIgnoreCase(cm.containerType))
            op.isListContainer = Boolean.TRUE;
          else if ("array".equalsIgnoreCase(cm.containerType))
            op.isListContainer = Boolean.TRUE;
        }
        else
          op.returnSimpleType = true;
        if (languageSpecificPrimitives().contains(op.returnBaseType) || op.returnBaseType == null)
          op.returnTypeIsPrimitive = true;
      }
      addHeaders(methodResponse, op.responseHeaders);
    }
    }

    List<Parameter> parameters = operation.getParameters();
    CodegenParameter bodyParam = null;
    List<CodegenParameter> allParams = new ArrayList<CodegenParameter>();
    List<CodegenParameter> bodyParams = new ArrayList<CodegenParameter>();
    List<CodegenParameter> pathParams = new ArrayList<CodegenParameter>();
    List<CodegenParameter> queryParams = new ArrayList<CodegenParameter>();
    List<CodegenParameter> headerParams = new ArrayList<CodegenParameter>();
    List<CodegenParameter> cookieParams = new ArrayList<CodegenParameter>();
    List<CodegenParameter> formParams = new ArrayList<CodegenParameter>();

    if(parameters != null) {
      for(Parameter param : parameters) {
        CodegenParameter p = fromParameter(param, imports);
        allParams.add(p);
        if(param instanceof QueryParameter) {
          p.isQueryParam = new Boolean(true);
          queryParams.add(p.copy());
        }
        else if(param instanceof PathParameter) {
          p.required = true;
          p.isPathParam = new Boolean(true);
          pathParams.add(p.copy());
        }
        else if(param instanceof HeaderParameter) {
          p.isHeaderParam = new Boolean(true);
          headerParams.add(p.copy());
        }
        else if(param instanceof CookieParameter) {
          p.isCookieParam = new Boolean(true);
          cookieParams.add(p.copy());
        }
        else if(param instanceof BodyParameter) {
          p.isBodyParam = new Boolean(true);
          bodyParam = p;
          bodyParams.add(p.copy());
        }
        else if(param instanceof FormParameter) {
          if("file".equalsIgnoreCase(((FormParameter)param).getType()))
            p.isFile = true;
          else
            p.notFile = true;
          p.isFormParam = new Boolean(true);
          formParams.add(p.copy());
        }
      }
    }
    for(String i: imports) {
      if(!defaultIncludes.contains(i) && !languageSpecificPrimitives.contains(i)){
        op.imports.add(i);
      }
    }
    op.bodyParam = bodyParam;
    op.httpMethod = httpMethod.toUpperCase();
    op.lcHttpMethod = httpMethod.toLowerCase();
    op.allParams = addHasMore(allParams);
    op.bodyParams = addHasMore(bodyParams);
    op.pathParams = addHasMore(pathParams);
    op.queryParams = addHasMore(queryParams);
    op.headerParams = addHasMore(headerParams);
    // op.cookieParams = cookieParams;
    op.formParams = addHasMore(formParams);
    // legacy support
    op.nickname = operationId;

    if(op.allParams.size() > 0)
      op.hasParams = true;
    op.externalDocs = operation.getExternalDocs();

    return op;
  }

  public CodegenResponse fromResponse(String responseCode, Response response) {
    CodegenResponse r = CodegenModelFactory.newInstance(CodegenModelType.RESPONSE);
    if("default".equals(responseCode))
      r.code = "0";
    else
      r.code = responseCode;
    r.message = response.getDescription();
    r.schema = response.getSchema();
    r.examples = toExamples(response.getExamples());
    r.jsonSchema = Json.pretty(response);
    addHeaders(response, r.headers);

    if (r.schema != null) {
      Property responseProperty = response.getSchema();
      responseProperty.setRequired(true);
      CodegenProperty cm = fromProperty("response", responseProperty);

      if(responseProperty instanceof ArrayProperty) {
        ArrayProperty ap = (ArrayProperty) responseProperty;
        CodegenProperty innerProperty = fromProperty("response", ap.getItems());
        r.baseType = innerProperty.baseType;
      }
      else {
        if(cm.complexType != null)
          r.baseType = cm.complexType;
        else
          r.baseType = cm.baseType;
      }
      r.dataType = cm.datatype;
      if(cm.isContainer != null) {
        r.simpleType = false;
        r.containerType = cm.containerType;
        r.isMapContainer = "map".equals(cm.containerType);
        r.isListContainer = "list".equals(cm.containerType);
      }
      else
        r.simpleType  = true;
      r.primitiveType = (r.baseType == null ||languageSpecificPrimitives().contains(r.baseType));
    }
    if (r.baseType == null) {
      r.isMapContainer = false;
      r.isListContainer = false;
      r.primitiveType = true;
      r.simpleType = true;
    }
    return r;
  }

  public CodegenParameter fromParameter(Parameter param, Set<String> imports) {
    CodegenParameter p = CodegenModelFactory.newInstance(CodegenModelType.PARAMETER);
    p.baseName = param.getName();
    p.description = escapeText(param.getDescription());
    if(param.getRequired())
      p.required = param.getRequired();
    p.jsonSchema = Json.pretty(param);

    if(param instanceof SerializableParameter) {
      SerializableParameter qp = (SerializableParameter) param;
      Property property = null;
      String collectionFormat = null;
      if("array".equals(qp.getType())) {
        Property inner = qp.getItems();
        if(inner == null) {
          LOGGER.warn("warning!  No inner type supplied for array parameter \"" + qp.getName() + "\", using String");
          inner = new StringProperty().description("//TODO automatically added by swagger-codegen");
        }
        property = new ArrayProperty(inner);
        collectionFormat = qp.getCollectionFormat();
        CodegenProperty pr = fromProperty("inner", inner);
        p.baseType = pr.datatype;
        imports.add(pr.baseType);
      }
      else
        property = PropertyBuilder.build(qp.getType(), qp.getFormat(), null);
      if(property == null) {
        LOGGER.warn("warning!  Property type \"" + qp.getType() + "\" not found for parameter \"" + param.getName() + "\", using String");
        property = new StringProperty().description("//TODO automatically added by swagger-codegen.  Type was " + qp.getType() + " but not supported");
      }
      CodegenProperty model = fromProperty(qp.getName(), property);
      p.collectionFormat = collectionFormat;
      p.dataType = model.datatype;
      p.paramName = toParamName(qp.getName());

      if(model.complexType != null) {
        imports.add(model.complexType);
      }
    }
    else {
      BodyParameter bp = (BodyParameter) param;
      Model model = bp.getSchema();

      if(model instanceof ModelImpl) {
        ModelImpl impl = (ModelImpl) model;
        CodegenModel cm = fromModel(bp.getName(), impl);
        if(cm.emptyVars != null && cm.emptyVars == false) {
          p.dataType = getTypeDeclaration(cm.classname);
          imports.add(p.dataType);
        }
        else {
          // TODO: missing format, so this will not always work
          Property prop = PropertyBuilder.build(impl.getType(), null, null);
          CodegenProperty cp = fromProperty("property", prop);
          if(cp != null) {
            p.dataType = cp.datatype;
          }
        }
      }
      else if(model instanceof ArrayModel) {
        // to use the built-in model parsing, we unwrap the ArrayModel
        // and get a single property from it
        ArrayModel impl = (ArrayModel) model;
        CodegenModel cm = fromModel(bp.getName(), impl);
        // get the single property
        ArrayProperty ap = new ArrayProperty().items(impl.getItems());
        CodegenProperty cp = fromProperty("inner", ap);
        if(cp.complexType != null) {
          imports.add(cp.complexType);
        }
        imports.add(cp.baseType);
        p.dataType = cp.datatype;
        p.isContainer = true;
      }
      else{
        Model sub = bp.getSchema();
        if(sub instanceof RefModel) {
          String name = ((RefModel)sub).getSimpleRef();
          if(typeMapping.containsKey(name))
            name = typeMapping.get(name);
          else {
            name = toModelName(name);
            if(defaultIncludes.contains(name)) {
              imports.add(name);
            }
            imports.add(name);
            name = getTypeDeclaration(name);
          }
          p.dataType = name;
        }
      }
      p.paramName = toParamName(bp.getName());
    }
    return p;
  }

  public List<CodegenSecurity> fromSecurity(Map<String, SecuritySchemeDefinition> schemes) {
    if(schemes == null)
      return null;

    List<CodegenSecurity> secs = new ArrayList<CodegenSecurity>();
    for(Iterator entries = schemes.entrySet().iterator(); entries.hasNext(); ) {
      Map.Entry<String, SecuritySchemeDefinition> entry = (Map.Entry<String, SecuritySchemeDefinition>) entries.next();
      final SecuritySchemeDefinition schemeDefinition = entry.getValue();

      CodegenSecurity sec = CodegenModelFactory.newInstance(CodegenModelType.SECURITY);
      sec.name = entry.getKey();
      sec.type = schemeDefinition.getType();

      if (schemeDefinition instanceof ApiKeyAuthDefinition) {
        final ApiKeyAuthDefinition apiKeyDefinition = (ApiKeyAuthDefinition) schemeDefinition;
        sec.isBasic = sec.isOAuth = false;
        sec.isApiKey = true;
        sec.keyParamName = apiKeyDefinition.getName();
        sec.isKeyInHeader = apiKeyDefinition.getIn() == In.HEADER;
        sec.isKeyInQuery = !sec.isKeyInHeader;
      } else {
        sec.isKeyInHeader = sec.isKeyInQuery = sec.isApiKey = false;
        sec.isBasic = schemeDefinition instanceof BasicAuthDefinition;
        sec.isOAuth = !sec.isBasic;
      }

      sec.hasMore = entries.hasNext();
      secs.add(sec);
    }
    return secs;
  }

  protected List<Map<String, String>> toExamples(Map<String, String> examples) {
    if(examples == null)
      return null;

    List<Map<String, String>> output = new ArrayList<Map<String, String>>();
    for(String key: examples.keySet()) {
      String value = examples.get(key);

      Map<String, String> kv = new HashMap<String, String>();
      kv.put("contentType", key);
      kv.put("example", value);
      output.add(kv);
    }
    return output;
  }

  private void addHeaders(Response response, List<CodegenProperty> target) {
    if (response.getHeaders() != null) {
      for (Map.Entry<String, Property> headers : response.getHeaders().entrySet()) {
        target.add(fromProperty(headers.getKey(), headers.getValue()));
      }
    }
  }

  private List<CodegenParameter> addHasMore(List<CodegenParameter> objs) {
    if(objs != null) {
      for(int i = 0; i < objs.size(); i++) {
        if(i > 0)
          objs.get(i).secondaryParam = new Boolean(true);
        if(i < objs.size() - 1)
          objs.get(i).hasMore = new Boolean(true);
      }
    }
    return objs;
  }

  private Map<String, Object> addHasMore(Map<String, Object> objs) {
    if(objs != null) {
      for(int i = 0; i < objs.size() - 1; i++) {
        if(i > 0)
          objs.put("secondaryParam", new Boolean(true));
        if(i < objs.size() - 1)
          objs.put("hasMore", true);
      }
    }
    return objs;
  }


  public void addOperationToGroup(String tag, String resourcePath, Operation operation, CodegenOperation co, Map<String, List<CodegenOperation>> operations) {
    List<CodegenOperation> opList = operations.get(tag);
    if(opList == null) {
      opList = new ArrayList<CodegenOperation>();
      operations.put(tag, opList);
    }
    opList.add(co);
    co.baseName = tag;
  }

  /* underscore and camelize are copied from Twitter elephant bird
   * https://github.com/twitter/elephant-bird/blob/master/core/src/main/java/com/twitter/elephantbird/util/Strings.java
   */

  /**
   * Underscore the given word.
   * @param word The word
   * @return The underscored version of the word
   */
  public static String underscore(String word) {
    String firstPattern = "([A-Z]+)([A-Z][a-z])";
    String secondPattern = "([a-z\\d])([A-Z])";
    String replacementPattern = "$1_$2";
    // Replace package separator with slash.
    word = word.replaceAll("\\.", "/");
    // Replace $ with two underscores for inner classes.
    word = word.replaceAll("\\$", "__");
    // Replace capital letter with _ plus lowercase letter.
    word = word.replaceAll(firstPattern, replacementPattern);
    word = word.replaceAll(secondPattern, replacementPattern);
    word = word.replace('-', '_');
    word = word.toLowerCase();
    return word;
  }

  public static String camelize(String word) {
    return camelize(word, false);
  }

  public static String camelize(String word, boolean lowercaseFirstLetter) {
    // Replace all slashes with dots (package separator)
    Pattern p = Pattern.compile("\\/(.?)");
    Matcher m = p.matcher(word);
    while (m.find()) {
      word = m.replaceFirst("." + m.group(1)/*.toUpperCase()*/);
      m = p.matcher(word);
    }

    // case out dots
    String[] parts = word.split("\\.");
    StringBuilder f = new StringBuilder();
    for(String z : parts) {
      if(z.length() > 0)
        f.append(Character.toUpperCase(z.charAt(0))).append(z.substring(1));
    }
    word = f.toString();

    m = p.matcher(word);
    while (m.find()) {
      word = m.replaceFirst("" + Character.toUpperCase(m.group(1).charAt(0)) + m.group(1).substring(1)/*.toUpperCase()*/);
      m = p.matcher(word);
    }

    // Uppercase the class name.
    p = Pattern.compile("(\\.?)(\\w)([^\\.]*)$");
    m = p.matcher(word);
    if (m.find()) {
      String rep = m.group(1) + m.group(2).toUpperCase() + m.group(3);
      rep = rep.replaceAll("\\$", "\\\\\\$");
      word = m.replaceAll(rep);
    }

    // Replace two underscores with $ to support inner classes.
    p = Pattern.compile("(__)(.)");
    m = p.matcher(word);
    while (m.find()) {
      word = m.replaceFirst("\\$" + m.group(2).toUpperCase());
      m = p.matcher(word);
    }

    // Remove all underscores
    p = Pattern.compile("(_)(.)");
    m = p.matcher(word);
    while (m.find()) {
      word = m.replaceFirst(m.group(2).toUpperCase());
      m = p.matcher(word);
    }

    if (lowercaseFirstLetter) {
      word = word.substring(0, 1).toLowerCase() + word.substring(1);
    }

    return word;
  }


}
package com.wordnik.swagger.codegen;

import com.samskivert.mustache.Mustache;
import com.samskivert.mustache.Template;
import com.wordnik.swagger.models.Contact;
import com.wordnik.swagger.models.Info;
import com.wordnik.swagger.models.License;
import com.wordnik.swagger.models.Model;
import com.wordnik.swagger.models.Operation;
import com.wordnik.swagger.models.Path;
import com.wordnik.swagger.models.Swagger;
import com.wordnik.swagger.models.auth.SecuritySchemeDefinition;
import com.wordnik.swagger.util.Json;

import org.apache.commons.io.FileUtils;
import org.apache.commons.io.IOUtils;

import java.io.File;
import java.io.Reader;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.FileInputStream;
import java.io.FileOutputStream;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import static org.apache.commons.lang3.StringUtils.capitalize;
import static org.apache.commons.lang3.StringUtils.isNotEmpty;

public class DefaultGenerator extends AbstractGenerator implements Generator {
  Logger LOGGER = LoggerFactory.getLogger(DefaultGenerator.class);
  protected CodegenConfig config;
  protected ClientOptInput opts = null;
  protected Swagger swagger = null;

  public Generator opts(ClientOptInput opts) {
    this.opts = opts;

    this.swagger = opts.getSwagger();
    this.config = opts.getConfig();
    this.config.additionalProperties().putAll(opts.getOpts().getProperties());

    return this;
  }

  public List<File> generate() {
    if (swagger == null || config == null) {
      throw new RuntimeException("missing swagger input or config!");
    }
    if (System.getProperty("debugSwagger") != null) {
      Json.prettyPrint(swagger);
    }
    List<File> files = new ArrayList<File>();
    try {
      config.processOpts();
      if (swagger.getInfo() != null) {
        Info info = swagger.getInfo();
        if (info.getTitle() != null) {
          config.additionalProperties().put("appName", info.getTitle());
        }
        if (info.getVersion() != null) {
          config.additionalProperties().put("appVersion", info.getVersion());
        }
        if (info.getDescription() != null) {
          config.additionalProperties().put("appDescription",
            config.escapeText(info.getDescription()));
        }
        if (info.getContact() != null) {
          Contact contact = info.getContact();
          config.additionalProperties().put("infoUrl", contact.getUrl());
          if (contact.getEmail() != null) {
            config.additionalProperties().put("infoEmail", contact.getEmail());
          }
        }
        if (info.getLicense() != null) {
          License license = info.getLicense();
          if (license.getName() != null) {
            config.additionalProperties().put("licenseInfo", license.getName());
          }
          if (license.getUrl() != null) {
            config.additionalProperties().put("licenseUrl", license.getUrl());
          }
        }
        if (info.getVersion() != null) {
          config.additionalProperties().put("version", info.getVersion());
        }
      }

      StringBuilder hostBuilder = new StringBuilder();
      if (swagger.getSchemes() != null && swagger.getSchemes().size() > 0) {
        hostBuilder.append(swagger.getSchemes().get(0).toValue());
        hostBuilder.append("://");
      } else {
        hostBuilder.append("https://");
      }
      if (swagger.getHost() != null) {
        hostBuilder.append(swagger.getHost());
      } else {
        hostBuilder.append("localhost");
      }
      if (swagger.getBasePath() != null) {
        hostBuilder.append(swagger.getBasePath());
      } else {
        hostBuilder.append("/");
      }
      String contextPath = swagger.getBasePath() == null ? "/" : swagger.getBasePath();
      String basePath = hostBuilder.toString();


      List<Object> allOperations = new ArrayList<Object>();
      List<Object> allModels = new ArrayList<Object>();

      // models
      Map<String, Model> definitions = swagger.getDefinitions();
      if (definitions != null) {
        for (String name : definitions.keySet()) {
          Model model = definitions.get(name);
          Map<String, Model> modelMap = new HashMap<String, Model>();
          modelMap.put(name, model);
          Map<String, Object> models = processModels(config, modelMap);
          models.putAll(config.additionalProperties());

          allModels.add(((List<Object>) models.get("models")).get(0));

          for (String templateName : config.modelTemplateFiles().keySet()) {
            String suffix = config.modelTemplateFiles().get(templateName);
            String filename = config.modelFileFolder() + File.separator + config.toModelFilename(name) + suffix;
            if (name.endsWith("Collection")) {
              templateName = "collection.mustache";
            }
            String template = readTemplate(config.templateDir() + File.separator + templateName);
            Template tmpl = Mustache.compiler()
                    .withLoader(new Mustache.TemplateLoader() {
                      public Reader getTemplate(String name) {
                        return getTemplateReader(config.templateDir() + File.separator + name + ".mustache");
                      }
                    })
                    .defaultValue("")
                    .compile(template);
            writeToFile(filename, tmpl.execute(models));
            files.add(new File(filename));
          }
        }
      }
      if (System.getProperty("debugModels") != null) {
        System.out.println("############ Model info ############");
        Json.prettyPrint(allModels);
      }

      // apis
      Map<String, List<CodegenOperation>> paths = processPaths(swagger.getPaths());
      for (String tag : paths.keySet()) {
        List<CodegenOperation> ops = paths.get(tag);
        Map<String, Object> operation = processOperations(config, tag, ops);
        operation.put("basePath", basePath);
        operation.put("contextPath", contextPath);
        operation.put("baseName", tag);
        operation.put("modelPackage", config.modelPackage());
        operation.putAll(config.additionalProperties());
        operation.put("classname", config.toApiName(tag));
        operation.put("classVarName", config.toApiVarName(tag));

        allOperations.add(new HashMap<String, Object>(operation));
        for (int i = 0; i < allOperations.size(); i++) {
          Map<String, Object> oo = (Map<String, Object>) allOperations.get(i);
          if (i < (allOperations.size() - 1)) {
            oo.put("hasMore", "true");
          }
        }

        for (String templateName : config.apiTemplateFiles().keySet()) {
          String suffix = config.apiTemplateFiles().get(templateName);
          String filename = config.apiFileFolder() +
                  File.separator +
                  config.toApiFilename(tag) +
                  suffix;

          String template = readTemplate(config.templateDir() + File.separator + templateName);
          Template tmpl = Mustache.compiler()
                  .withLoader(new Mustache.TemplateLoader() {
                    public Reader getTemplate(String name) {
                      return getTemplateReader(config.templateDir() + File.separator + name + ".mustache");
                    }
                  })
                  .defaultValue("")
                  .compile(template);

          writeToFile(filename, tmpl.execute(operation));
          files.add(new File(filename));
        }
      }
      if (System.getProperty("debugOperations") != null) {
        System.out.println("############ Operation info ############");
        Json.prettyPrint(allOperations);
      }

      // supporting files
      Map<String, Object> bundle = new HashMap<String, Object>();
      bundle.putAll(config.additionalProperties());
      bundle.put("apiPackage", config.apiPackage());

      Map<String, Object> apis = new HashMap<String, Object>();
      apis.put("apis", allOperations);
      if (swagger.getHost() != null) {
        bundle.put("host", swagger.getHost());
      }
      bundle.put("basePath", basePath);
      bundle.put("contextPath", contextPath);
      bundle.put("apiInfo", apis);
      bundle.put("models", allModels);
      bundle.put("apiFolder", config.apiPackage().replace('.', File.separatorChar));
      bundle.put("modelPackage", config.modelPackage());
      if (swagger.getExternalDocs() != null) {
        bundle.put("externalDocs", swagger.getExternalDocs());
      }
      for (int i = 0; i < allModels.size() - 1; i++) {
        HashMap<String, CodegenModel> cm = (HashMap<String, CodegenModel>) allModels.get(i);
        CodegenModel m = cm.get("model");
        m.hasMoreModels = true;
      }

      config.postProcessSupportingFileData(bundle);

      if (System.getProperty("debugSupportingFiles") != null) {
        System.out.println("############ Supporting file info ############");
        Json.prettyPrint(bundle);
      }

      for (SupportingFile support : config.supportingFiles()) {
        String outputFolder = config.outputFolder();
        if (isNotEmpty(support.folder)) {
          outputFolder += File.separator + support.folder;
        }
        File of = new File(outputFolder);
        if (!of.isDirectory()) {
          of.mkdirs();
        }
        String outputFilename = outputFolder + File.separator + support.destinationFilename;

        if (support.templateFile.endsWith("mustache")) {
          String template = readTemplate(config.templateDir() + File.separator + support.templateFile);
          Template tmpl = Mustache.compiler()
                  .withLoader(new Mustache.TemplateLoader() {
                    public Reader getTemplate(String name) {
                      return getTemplateReader(config.templateDir() + File.separator + name + ".mustache");
                    }
                  })
                  .defaultValue("")
                  .compile(template);

          writeToFile(outputFilename, tmpl.execute(bundle));
          files.add(new File(outputFilename));
        } else {
          InputStream in = null;

          try {
            in = new FileInputStream(config.templateDir() + File.separator + support.templateFile);
          }
          catch (Exception e) {
            // continue
          }
          if(in == null) {
            in = this.getClass().getClassLoader().getResourceAsStream(config.templateDir() + File.separator + support.templateFile);
          }
          File outputFile = new File(outputFilename);
          OutputStream out = new FileOutputStream(outputFile, false);
          if(in != null && out != null)
            IOUtils.copy(in,out);
          else {
            if(in == null)
              System.out.println("can't open " + config.templateDir() + File.separator + support.templateFile + " for input");
            if(out == null)
              System.out.println("can't open " + outputFile + " for output");
          }

          files.add(outputFile);
        }
      }

      config.processSwagger(swagger);
    } catch (Exception e) {
      e.printStackTrace();
    }
    return files;
  }

  public Map<String, List<CodegenOperation>> processPaths(Map<String, Path> paths) {
    Map<String, List<CodegenOperation>> ops = new HashMap<String, List<CodegenOperation>>();

    for (String resourcePath : paths.keySet()) {
      Path path = paths.get(resourcePath);
      processOperation(resourcePath, "get", path.getGet(), ops);
      processOperation(resourcePath, "put", path.getPut(), ops);
      processOperation(resourcePath, "post", path.getPost(), ops);
      processOperation(resourcePath, "delete", path.getDelete(), ops);
      processOperation(resourcePath, "patch", path.getPatch(), ops);
      processOperation(resourcePath, "options", path.getOptions(), ops);
    }
    return ops;
  }

  public SecuritySchemeDefinition fromSecurity(String name) {
    Map<String, SecuritySchemeDefinition> map = swagger.getSecurityDefinitions();
    if (map == null) {
      return null;
    }
    return map.get(name);
  }


  public void processOperation(String resourcePath, String httpMethod, Operation operation, Map<String, List<CodegenOperation>> operations) {
    if (operation != null) {
      List<String> tags = operation.getTags();
      if (tags == null) {
        tags = new ArrayList<String>();
        tags.add("default");
      }

      for (String tag : tags) {
        CodegenOperation co = config.fromOperation(resourcePath, httpMethod, operation, swagger.getDefinitions());
        co.tags = new ArrayList<String>();
        co.tags.add(sanitizeTag(tag));
        config.addOperationToGroup(sanitizeTag(tag), resourcePath, operation, co, operations);

        List<Map<String, List<String>>> securities = operation.getSecurity();
        if (securities == null) {
          continue;
        }
        Map<String, SecuritySchemeDefinition> authMethods = new HashMap<String, SecuritySchemeDefinition>();
        for (Map<String, List<String>> security : securities) {
          if (security.size() != 1) {
            //Not sure what to do
            continue;
          }
          String securityName = security.keySet().iterator().next();
          SecuritySchemeDefinition securityDefinition = fromSecurity(securityName);
          if (securityDefinition != null) {
            authMethods.put(securityName, securityDefinition);
          }
        }
        if (!authMethods.isEmpty()) {
          co.authMethods = config.fromSecurity(authMethods);
        }
      }
    }
  }

  protected String sanitizeTag(String tag) {
    // remove spaces and make strong case
    String[] parts = tag.split(" ");
    StringBuilder buf = new StringBuilder();
    for (String part : parts) {
      if (isNotEmpty(part)) {
        buf.append(capitalize(part));
      }
    }
    return buf.toString().replaceAll("[^a-zA-Z ]", "");
  }

  public Map<String, Object> processOperations(CodegenConfig config, String tag, List<CodegenOperation> ops) {
    Map<String, Object> operations = new HashMap<String, Object>();
    Map<String, Object> objs = new HashMap<String, Object>();
    objs.put("classname", config.toApiName(tag));
    objs.put("operation", ops);
    operations.put("operations", objs);
    operations.put("package", config.apiPackage());

    Set<String> allImports = new LinkedHashSet<String>();
    for (CodegenOperation op : ops) {
      allImports.addAll(op.imports);
    }

    List<Map<String, String>> imports = new ArrayList<Map<String, String>>();
    for (String nextImport : allImports) {
      Map<String, String> im = new LinkedHashMap<String, String>();
      String mapping = config.importMapping().get(nextImport);
      if (mapping == null) {
        mapping = config.toModelImport(nextImport);
      }
      if (mapping != null) {
        im.put("import", mapping);
        imports.add(im);
      }
    }

    operations.put("imports", imports);
    config.postProcessOperations(operations);
    if (objs.size() > 0) {
      List<CodegenOperation> os = (List<CodegenOperation>) objs.get("operation");

      if (os != null && os.size() > 0) {
        CodegenOperation op = os.get(os.size() - 1);
        op.hasMore = null;
      }
    }
    return operations;
  }

  public Map<String, Object> processModels(CodegenConfig config, Map<String, Model> definitions) {
    Map<String, Object> objs = new HashMap<String, Object>();
    objs.put("package", config.modelPackage());
    List<Object> models = new ArrayList<Object>();
    Set<String> allImports = new LinkedHashSet<String>();
    for (String key : definitions.keySet()) {
      Model mm = definitions.get(key);
      CodegenModel cm = config.fromModel(key, mm);
      Map<String, Object> mo = new HashMap<String, Object>();
      mo.put("model", cm);
      models.add(mo);
      allImports.addAll(cm.imports);
    }
    objs.put("models", models);

    List<Map<String, String>> imports = new ArrayList<Map<String, String>>();
    for (String nextImport : allImports) {
      Map<String, String> im = new LinkedHashMap<String, String>();
      String mapping = config.importMapping().get(nextImport);
      if (mapping == null) {
        mapping = config.toModelImport(nextImport);
      }
      if (mapping != null && !config.defaultIncludes().contains(mapping)) {
        im.put("import", mapping);
        imports.add(im);
      }
      // add instantiation types
      mapping = config.instantiationTypes().get(nextImport);
      if (mapping != null && !config.defaultIncludes().contains(mapping)) {
        im.put("import", mapping);
        imports.add(im);
      }
    }

    objs.put("imports", imports);
    config.postProcessModels(objs);

    return objs;
  }
}
